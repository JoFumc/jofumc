<?php
/****************************************************************************
 * class-table.php -- Define a dynamic spreadsheet-style table.
 ***************************************************************************/
/*
 * INCLUDES
 */
require_once("library/core/util-auth.php");
require_once("library/core/util-file.php");

  /* Simple rendering of the existing data */
define("TABLE_OPERATION_DISPLAY","display");
  /* Edit existing table data.  Error if table can't be found */
define("TABLE_OPERATION_EDIT","edit");
  /* Create new table */
define("TABLE_OPERATION_CREATE","create");

  /* TABLE file signature */
define("TABLE_FILE_SIGNATURE","AKTBL");

/*
 * akTableCell -- Table cell object
 */
class akTableCell
{
  public $col; /* Which (zero-based) column this cell is in */
  public $row; /* Which (zero-based) row this cell is in */
    /* There are two levels of formatting: class-based (from skin css), and
       simple (common, predefined formatting tags).
     */
  public $format_class; /* Which (skin-provided) display class to apply */
  public $format_simple; /* Array of simple formatting tags to apply, regardless of class */
  public $contents; /* Actual contents of cell */

  public function __construct($contentString=null) {
       /* Initialize to base values */
      $this->col = 0;
      $this->row = 0;
      $this->format_class = null;
      $this->format_simple = null;
      $this->contents = '';
      if ($contentString != null) {
        list($params,$this->contents) = explode('=',$contentString,2);
        list($this->col,$this->row,$this->format_simple,$this->format_class) = explode(',',$params,4);
      }
  }

  public static function createEmptyCell($col, $row) {
    $instance = new self(null);
    $instance->col = $col;
    $instance->row = $row;
    return $instance;
  }

  private function render_display() {
    /* "Simple" formatting */
    $simple_open = "";
    $simple_close = "";
    foreach (str_split($this->format_simple) as $formatChar) {
       switch($formatChar) {
         case 'b': {
           $simple_start = "<b>";
           $simple_end = "</b>";
           break;
         }
         case 'c': {
           $simple_start = "<center>";
           $simple_end = "</center>";
           break;
         }
         case 'i': {
           $simple_start = "<i>";
           $simple_end = "</i>";
           break;
         }
         default: {
           /* ERROR! What to do here? */
           $simple_start = "";
           $simple_end = "";
         }
       } /* End switch */
       $simple_open = $simple_open.$simple_start;
       $simple_close = $simple_end.$simple_close;
    } /* End simple formatting setup */
    print $simple_open;
    print $this->contents;
    print $simple_close;
  }

  private function render_edit() {
    /* For editing, we don't add the formatting inline, but add buttons */
    print '<input type="text" value="'.$this->contents.'"/>';
  }

  /* Emit the HTML for this cell */
  public function emit($mode=TABLE_OPERATION_DISPLAY) {
    /* Opening tag */
    if (null == $this->format_class) {
      print '<td>';
    } else {
      print '<td class="'.$this->format_class.'">';
    }

    switch($mode) {
      case TABLE_OPERATION_EDIT: $this->render_edit();break;
      default: $this->render_display(); break;
    }

    print "</td>\n";
  }

}

/*
 * akTableFile -- subclass the generic text file for our formatting
 */
class akTableFile extends akTextFile {
  /* 
   * Override the line processing.  We strip whitespace, ignore comments, 
   * and decode URL-encoded entities (but not other HTML entities!)
   */
  public function decodeText($line) {
    /* Remove leading/trailing whitespace */
    $line = trim($line);
      /* Ignore empty... */
    if (strlen($line) <= 0) return FALSE;
      /* Ignore comments */
    if (substr($line,0,1) == "#") return FALSE;

    return $line;
  }
}

/*
 * akTable -- Basic table object
 *
 * NOTE: The table cell array may contain values that are outside
 *       the range defined by $rows/$colums, but we control the render
 *       based on the metadata, not the contents.
 */
class akTable 
{
  public $dom_tag;   // DOM element tag for this table
  public $operation; // What to do to this table...
  public $title;    // Table title
  public $height;   // Number of table rows
  public $width;    // Number of table columns
  public $backing;  // Backing store (filepath)
  public $editable; // Render as editable? 
  public $cells;    // The array of cells
  public $error;    // Did something go wrong?

  /* Construction */
    /* See the factory methods below, since we can't
       simply overload the constructor (forms are 
       different, but the types of args are the same!)
      */
  public function __construct($newtitle='Table')
  {
    $this->cells = array(array());
    $this->error = null;
    if ($_GET && $_GET["mode"]) {
      $this->operation = $_GET["mode"];
    } else {
      $this->operation = TABLE_OPERATION_DISPLAY;
    }
    /* Random tag.  Doesn't need to be persistent (e.g. between file loads),
     * but it needs to be consistent through any single page load.
     */
    $this->dom_tag = "editable-table-".rand(10000,99999);
  }

  public static function fromScratch($newTitle='Table',$colCount='1',$rowCount='1') 
  {
    $instance = new self();
    $instance->title = $newTitle;
    $instance->width = $colCount;
    $instance->height = $rowCount;
    $instance->backing = null;
    return $instance;
  }

  public static function fromFile($backingPath=null) 
  {
    $instance = new self();
    $store = null;

    if (null == $backingPath) {
          $instance->error = "[[Syntax error in fromFile(): no file path given.";
          return;
    }
    switch ($instance->operation) {
      case TABLE_OPERATION_DISPLAY: {
        if (!is_readable($backingPath)) {
          $instance->error = "[[Can't load table data for path ".$backingPath.", giving up.]]";
        } else {
          /* Open, but don't parse yet */
          $store = new akTableFile($backingPath);
        }
        $instance->backing = $backingPath;
        break;
      }
      case TABLE_OPERATION_EDIT: {
        if (!is_readable($backingPath)) {
          $instance->error = "[[Can't load table data for path ".$backingPath.", giving up.]]";
        }
        else if (!is_writable($backingPath)) {
          $instance->error = "[[Table data for ".$backingPath." is read-only.]]";
        } else {
          /* Open, but don't parse yet */
            /* NOTE: Although we may update later, we're only reading right now. */
          $store = new akTableFile($backingPath);
        }
        $instance->backing = $backingPath;
        break;
      }
      case TABLE_OPERATION_CREATE: {
        /* The file doesn't have to exist, but we need to fake some data if it isn't there */
          /* Default is an empty 2x2 table */
        $instance->backing = $backingPath;
        $instance->title = 'Table';
        $instance->width = 2;
        $instance->height = 2;
        $instance->cells = array(array());
        $instance->cells[0][0] = akTableCell::createEmptyCell(0,0);
        $instance->cells[0][1] = akTableCell::createEmptyCell(0,1);
        $instance->cells[1][0] = akTableCell::createEmptyCell(1,0);
        $instance->cells[1][1] = akTableCell::createEmptyCell(1,1);
        break;
      }
      default: {
        $instance->error = "[[Invalid table operation given.]]";
        break;
      }
    } /* End switch */
    /* Bail on any error */
    if (null != $instance->error) return $instance;


    /* Load from file */
    if (null != $store)  {
      /* Get signature */
      if (strcmp("AKTBL",$store->getLine())) {
        $instance->error = "[[Invalid backing store file format.  Can't read ".$backingPath." so I'm quitting.]]";
      } else {
        /* Pull basic metadata */
        $fileVersion = $store->getLine();
        $instance->title = $store->getLine();
        $instance->width = $store->getLine();
        $instance->height = $store->getLine();
        /* Here on down should be cells */
        while (null != ($cellInfo = $store->getLine())) {
          $cell = new akTableCell($cellInfo);
          $instance->cells[$cell->col][$cell->row] = $cell;
        }
      }
      $store->close();
    }
    return $instance;
  }

  /* 
   *  Father forgive me for using the outer table for layout instead of
   *  CSS.
    */
  private function emit_edit() {
    /* Error out if not authenticated */
    if (!is_authenticated() || !is_editor()) {
      $this->operation = TABLE_OPERATION_DISPLAY;
      $this->error = "[[Authentication failure.]]";
      $this->emit();
    }
    /* Authenticated.  Build form around a fixed djeiv */
    print '<div class="ak-table-editable" id="'.$this->dom_tag.'">';
    print '<center>';
    print '<table border="1px" id="table-form-layout-outer">'."\n";
    print '<tr><td>'; /* Start form cell */
    print '<form ';
    print '  id="table-form" ';
    print '  method="post" ';
    print '  action="'.$_SERVER['HTTP_REFERER'].'" ';
    print ">\n";
      /* Add some hidden fields for passing data */
    print '<input type="hidden" id="table-form-width" value="'.$this->width.'"/>';
    print '<input type="hidden" id="table-form-height" value="'.$this->height.'"/>';
    print '<input type="hidden" id="table-form-backing" value="'.$this->backing.'"/>';
      /* Create the table, with cells as input areas  */

    print 'Table Title: ';
    print '<input type="text" id="table-form-title" value="'.$this->title.'"/>';
    print '<table>';
    /* Content rows */
    for ($r = 0; $r < $this->height; $r++) {
      print "<tr>\n";
        for ($c =0; $c < $this->width; $c++) {
          if (null != $this->cells[$c][$r]) {
            $this->cells[$c][$r]->emit(TABLE_OPERATION_EDIT);
          }
        }
      print "</tr>\n";
    }
    print '</table>'; /* Actual editable table */

    print '</form>';
    print '</td>'; /* End form cell */
    print '<td id="table-form-add-column" align="center" valign="middle">';
    print '<input type="button" value="Add Column"/>';
    print '</tr><tr><td id="table-form-add-row" align="center" valign="middle">';
    print '<input type="button" value="Add Row"/>';
    print '</td>';
    print '<td>';
    print '<input type="button" value="Save"/>';
    print '<input type="button" value="Cancel"/>';
    print '</td>';
    print '</tr>';
    print '</table>'; /* Outer (layout) table */
    print '</center>';
    print '</div>';
    /* Run the JS to prescan the editable table */
    print '<script type="text/javascript">';
    print 'akTable_scan("'.$this->dom_tag.'");';
    print '</script>';


  }

  private function emit_display() {
    print "<center>\n"; /* All tables are centered?*/
    print $this->title."\n";
    /* If logged in as an editor, add link button */
    if (is_authenticated() && is_editor()) {
      print '<a ';
      print '  href="/edit-table.php?mode=edit&file='.$this->backing.'" ';
      print '  class="story-trail" ';
      print '  title="Modify this table" ';
      print '>';
      skin_img("edit_icon.png","Edit this text","story-trail");
      print '</a>';
    }
    print "<table border=1>\n";
    /* Content rows */
    for ($r = 0; $r < $this->height; $r++) {
      print "<tr>\n";
        for ($c =0; $c < $this->width; $c++) {
          if (null != $this->cells[$c][$r]) {
            $this->cells[$c][$r]->emit();
          }
        }
      print "</tr>\n";
    }
    print "</table>\n";
    print "</center>\n";
  }


  /* Method to emit the HTML for a table */
  public function emit()
  {
    if ($this->error != null) {
      /* Something went wrong */
      print '<br/><b>TABLE ERROR: '.$this->error.'</b><br/>';
      return;
    }
    /* Switch on operation.  If we're not authenticated, fall back to display */
    switch ($this->operation) {
      case TABLE_OPERATION_DISPLAY: $this->emit_display(); break;
      case TABLE_OPERATION_EDIT: $this->emit_edit(); break;
      case TABLE_OPERATION_CREATE: $this->emit_edit(); break;
    }
  }

}


?>
